import requests
import json
import traceback
import configparser  
import os

#read config file
EAZYML_URL = None
config = configparser.ConfigParser() 
config.read('config.ini')
config_error_message = "Unable to load EazyML Client Library. " \
                       "Please set the EAZYML_URL in config.ini" 
try:
    EAZYML_URL = config.get("URL", "EAZYML_URL")
    if not EAZYML_URL:
        print(config_error_message)
        exit()
except configparser.NoOptionError as e:
    print(config_error_message)
    exit()

APP_URL = EAZYML_URL.rstrip("/") + "/ez_app"

def exception_return(e, status_code):
    return_response = {"success": False, "status_code": status_code}
    try:
        raise(e)
    except requests.exceptions.HTTPError as errh:
        message = e
    except requests.exceptions.Timeout as errto:
        message = "Connection timeout", errto
    except requests.exceptions.TooManyRedirects as errtr:
        message = "Too many redirects", errtr
    except requests.exceptions.ConnectionError as errce:
        message = "Connection error", errce
    except requests.exceptions.RequestException as errre:
        message = "Connection error", errre
    except Exception as erre:
        message = "Exception", erre
    return_response["message"] = message
    return return_response


def ez_auth(username, password):
    """EazyML Authorization Function
    
    Parameters
    ----------
    username : type 'str'
        The username
    password : type 'str'
        Password for the username

    Returns
    -------
    return_response: type 'dict'
                    {
                     "success": <False|True>, 
                     "token"  : <None|string_token>
                     "status_code"  : <None|string_token>
                     "message"  : <None|string_token>
                    }
        The return dictionary will set success to True and update token if authentication
        is successful, else returns False and token set to None
    """
    status_code = 500
    try:
        APP_REQUEST_URL = APP_URL + "/ez_auth"
        payload = {
            "username": username,
            "password": password
        }
        headers = {
            "Content-Type": "application/json"
        }
        response = requests.request(
            "POST", APP_REQUEST_URL, headers = headers, data = json.dumps(payload)
        )
        status_code = response.status_code
        try:
            response_json = response.json()
        except Exception as e:
            response.raise_for_status()
        response_json["status_code"] = status_code
        return response_json
    except Exception as e:
        print((traceback.print_exc()))
        return exception_return(e, status_code)


def ez_sentiments(auth_token, filename = None,  text_columns = None, text = None, options = None):
    """Sentiment Computation App
    
    Parameters
    ----------
    auth_token: type 'str'
        The auth token generated by ez_auth function
    filename: type 'str'
        The dataset filename, must be an absolute path
    text_columns: type 'str'
        Text column name
    text: type 'str' or type 'list'
        Text for which the user wants to compute sentiments.
        Users can pass text also directly in this argument. If both are specified, filename will take precedence.
    options: type 'dict'
        For future options.
    Returns
    -------
    return_response: type 'dict'
        {
         "status_code": <http status code>
         "message": "Message from the server", 
         "success": <False|True>, 
         "dataframe": <None|dataframe>,
        }
        Where:
            status_code: HTTP status code. The status code returned could be 200, 400, 401, 422 and 500 
            message    : Message from the server, 
            success    : True if call successful else False
            dataframe  : Dictionary with keys as "data" and "columns". 
                         "data" is a list of rows with derived sentiment score
                         "columns" is a list of column names.
                                    
    """
    status_code = 500
    try:
        APP_REQUEST_URL = APP_URL + "/ez_sentiments"
        if filename:
            payload = {
                "text_columns": json.dumps(text_columns),
                "options": json.dumps(options)
            }
            files = [("filename", open(filename, "rb"))]
            headers = {
                "Authorization": "Bearer " + str(auth_token),
            }
            response = requests.request(
                "POST", APP_REQUEST_URL, headers = headers, data = payload, files = files
            )
        else:
            payload = {
                "text": text,
                "options": options
            }
            headers = {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + str(auth_token),
            }    
            response = requests.request(
                "POST", APP_REQUEST_URL, headers = headers, data = json.dumps(payload)
            )
        status_code = response.status_code
        try:
            response_json = response.json()
        except Exception as e:
            response.raise_for_status()
        response_json["status_code"] = status_code
        return response_json
    except Exception as e:
        print((traceback.print_exc()))
        return exception_return(e, status_code)


def ez_concepts(auth_token, phrases, filename = None,  text_columns = None, text = None, options = None):
    """Concept Extraction App
    
    Parameters
    ----------
    auth_token: type 'str'
        The auth token generated by ez_auth function
    phrases: <dict of lists>
        The phrases to be used for concept extraction. Only to be specified for those columns for which concept extraction is needed. 
        Ex: {"col_name":["phrase1", "phrase2"]}
    filename: type 'str'
        The dataset filename, must be an absolute path
    text_columns: type 'str'
        Text column name
    text: type 'str' or type 'list'
        Text for which the user wants to extract concepts.
        Users can pass text also directly in this argument. If both are specified, filename will take precedence.
    options: type 'dict'
        For future options.
    Returns
    -------
    return_response: type 'dict'
        {
         "status_code": <http status code>
         "message": "Message from the server", 
         "success": <False|True>, 
         "dataframe": <None|dataframe>,
        }
        Where:
            status_code: HTTP status code. The status code returned could be 200, 400, 401, 422 and 500 
            message    : Message from the server, 
            success    : True if call successful else False
            dataframe  : Dictionary with keys as "data" and "columns". 
                         "data" is a list of rows with derived concept columns
                         "columns" is a list of column names.
                                    
    """
    status_code = 500
    try:
        APP_REQUEST_URL = APP_URL + "/ez_concepts"
        if filename:
            payload = {
                "phrases": json.dumps(phrases),
                "text_columns": json.dumps(text_columns),
                "options": json.dumps(options)
            }
            files = [("filename", open(filename, "rb"))]
            headers = {
                "Authorization": "Bearer " + str(auth_token),
            }
            response = requests.request(
                "POST", APP_REQUEST_URL, headers = headers, data = payload, files = files
            )
        else:
            payload = {
                "text": text,
                "phrases": phrases,
                "options": options
            }
            headers = {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + str(auth_token),
            }    
            response = requests.request(
                "POST", APP_REQUEST_URL, headers = headers, data = json.dumps(payload)
            )
        status_code = response.status_code
        try:
            response_json = response.json()
        except Exception as e:
            response.raise_for_status()
        response_json["status_code"] = status_code
        return response_json
    except Exception as e:
        print((traceback.print_exc()))
        return exception_return(e, status_code)


def ez_topics(auth_token, filename = None,  text_columns = None, text = None, options = None):
    """Topic Modelling APP
    
    Parameters
    ----------
    auth_token: type 'str'
        The auth token generated by ez_auth function
    filename: type 'str'
        The dataset filename, must be an absolute path
    text_columns: type 'str'
        Text column name
    text: type 'str' or type 'list'
        Text for which the user wants to compute topics.
        Users can pass text also directly in this argument. If both are specified, filename will take precedence.
    options: type 'dict'
        For future options.
    Returns
    -------
    return_response: type 'dict'
        {
         "status_code": <http status code>
         "message": "Message from the server", 
         "success": <False|True>, 
         "dataframe": <None|dataframe>,
        }
        Where:
            status_code: HTTP status code. The status code returned could be 200, 400, 401, 422 and 500 
            message    : Message from the server, 
            success    : True if call successful else False
            dataframe  : Dictionary with keys as "data" and "columns". 
                         "data" is a list of rows with derived topic modelling columns
                         "columns" is a list of column names.
                                    
    """
    status_code = 500
    try:
        APP_REQUEST_URL = APP_URL + "/ez_topics"
        if filename:
            payload = {
                "text_columns": json.dumps(text_columns),
                "options": json.dumps(options)
            }
            files = [("filename", open(filename, "rb"))]
            headers = {
                "Authorization": "Bearer " + str(auth_token),
            }
            response = requests.request(
                "POST", APP_REQUEST_URL, headers = headers, data = payload, files = files
            )
        else:
            payload = {
                "text": text,
                "options": options
            }
            headers = {
                "Content-Type": "application/json",
                "Authorization": "Bearer " + str(auth_token),
            }    
            response = requests.request(
                "POST", APP_REQUEST_URL, headers = headers, data = json.dumps(payload)
            )
        status_code = response.status_code
        try:
            response_json = response.json()
        except Exception as e:
            response.raise_for_status()
        response_json["status_code"] = status_code
        return response_json
    except Exception as e:
        print((traceback.print_exc()))
        return exception_return(e, status_code)

